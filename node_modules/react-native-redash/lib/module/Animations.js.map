{"version":3,"sources":["Animations.ts"],"names":["Animated","min","Value","add","multiply","cond","eq","abs","sub","interpolate","divide","snapPoint","value","velocity","points","point","diffPoint","p","deltas","map","minDelta","reduce","acc","bInterpolate","origin","destination","inputRange","outputRange","translateZ","perspective","z","scale"],"mappings":"yEAAA,MAAOA,CAAAA,QAAP,KAAqB,yBAArB,CAEA,OAASC,GAAT,KAAoB,QAApB,C,GAGEC,CAAAA,K,CASEF,Q,CATFE,K,CACAC,G,CAQEH,Q,CARFG,G,CACAC,Q,CAOEJ,Q,CAPFI,Q,CACAC,I,CAMEL,Q,CANFK,I,CACAC,E,CAKEN,Q,CALFM,E,CACAC,G,CAIEP,Q,CAJFO,G,CACAC,G,CAGER,Q,CAHFQ,G,CACAC,W,CAEET,Q,CAFFS,W,CACAC,M,CACEV,Q,CADFU,M,CAGF,MAAO,IAAMC,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CACvBC,KADuB,CAEvBC,QAFuB,CAGvBC,MAHuB,CAIpB,CACH,GAAMC,CAAAA,KAAK,CAAGZ,GAAG,CAACS,KAAD,CAAQR,QAAQ,CAAC,GAAD,CAAMS,QAAN,CAAhB,CAAjB,CACA,GAAMG,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAACC,CAAD,QAAmCV,CAAAA,GAAG,CAACC,GAAG,CAACO,KAAD,CAAQE,CAAR,CAAJ,CAAtC,EAAlB,CACA,GAAMC,CAAAA,MAAM,CAAGJ,MAAM,CAACK,GAAP,CAAW,SAAAF,CAAC,QAAID,CAAAA,SAAS,CAACC,CAAD,CAAb,EAAZ,CAAf,CACA,GAAMG,CAAAA,QAAQ,CAAGnB,GAAG,MAAH,2BAAOiB,MAAP,EAAjB,CACA,MAAOJ,CAAAA,MAAM,CAACO,MAAP,CACL,SAACC,GAAD,CAA0BL,CAA1B,QACEZ,CAAAA,IAAI,CAACC,EAAE,CAACU,SAAS,CAACC,CAAD,CAAV,CAAeG,QAAf,CAAH,CAA6BH,CAA7B,CAAgCK,GAAhC,CADN,EADK,CAGL,GAAIpB,CAAAA,KAAJ,EAHK,CAAP,CAKD,CAdM,CAgBP,MAAO,IAAMqB,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAC1BX,KAD0B,CAE1BY,MAF0B,CAG1BC,WAH0B,QAK1BhB,CAAAA,WAAW,CAACG,KAAD,CAAQ,CACjBc,UAAU,CAAE,CAAC,CAAD,CAAI,CAAJ,CADK,CAEjBC,WAAW,CAAE,CAACH,MAAD,CAASC,WAAT,CAFI,CAAR,CALe,EAArB,CAUP,MAAO,IAAMG,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CACxBC,WADwB,CAExBC,CAFwB,QAGpB,CAAEC,KAAK,CAAErB,MAAM,CAACmB,WAAD,CAAcrB,GAAG,CAACqB,WAAD,CAAcC,CAAd,CAAjB,CAAf,CAHoB,EAAnB","sourcesContent":["import Animated from \"react-native-reanimated\";\n\nimport { min } from \"./Math\";\n\nconst {\n  Value,\n  add,\n  multiply,\n  cond,\n  eq,\n  abs,\n  sub,\n  interpolate,\n  divide\n} = Animated;\n\nexport const snapPoint = (\n  value: Animated.Adaptable<number>,\n  velocity: Animated.Adaptable<number>,\n  points: number[]\n) => {\n  const point = add(value, multiply(0.2, velocity));\n  const diffPoint = (p: Animated.Adaptable<number>) => abs(sub(point, p));\n  const deltas = points.map(p => diffPoint(p));\n  const minDelta = min(...deltas);\n  return points.reduce(\n    (acc: Animated.Node<any>, p: number) =>\n      cond(eq(diffPoint(p), minDelta), p, acc),\n    new Value()\n  );\n};\n\nexport const bInterpolate = (\n  value: Animated.Adaptable<number>,\n  origin: Animated.Adaptable<number>,\n  destination: Animated.Adaptable<number>\n) =>\n  interpolate(value, {\n    inputRange: [0, 1],\n    outputRange: [origin, destination]\n  });\n\nexport const translateZ = (\n  perspective: Animated.Adaptable<number>,\n  z: Animated.Adaptable<number>\n) => ({ scale: divide(perspective, sub(perspective, z)) });\n"]}